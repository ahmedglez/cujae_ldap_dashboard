'use client';
import { createElement, isValidElement, Fragment } from 'react';
import { createRoot } from 'react-dom/client';
import { a as RENDER_SCOPE, R as REGISTRY, b as REACT_ROOT } from './constants2.mjs';

const processProps = (props) => {
  const processedProps = {};
  for (const key in props) {
    const value = props[key];
    if (isValidElement(value)) {
      processedProps[key] = renderReactScope(value);
      continue;
    }
    processedProps[key] = props[key];
  }
  return processedProps;
};
const renderReactScope = (vnode, unstable) => {
  if (typeof window === "undefined") {
    return createElement(
      RENDER_SCOPE,
      { suppressHydrationWarning: true },
      vnode
    );
  }
  if (isValidElement(vnode) && typeof vnode.type === "function" && "callable" in vnode.type) {
    const puppetComponent = vnode.type(vnode.props);
    if (REGISTRY.has(puppetComponent.type)) {
      const puppetBlock = REGISTRY.get(puppetComponent.type);
      if (typeof puppetBlock === "function") {
        return puppetBlock(puppetComponent.props);
      }
    }
  }
  const scope = (el) => {
    const parent = el ?? document.createElement(RENDER_SCOPE);
    const root = REACT_ROOT in parent ? parent[REACT_ROOT] : parent[REACT_ROOT] = createRoot(parent);
    root.render(vnode);
    return parent;
  };
  if (unstable)
    scope.unstable = true;
  return scope;
};
const unwrap = (vnode) => {
  if (typeof vnode !== "object" || vnode === null || !("type" in vnode)) {
    if (typeof vnode === "number") {
      return String(vnode);
    }
    return vnode;
  }
  let type = vnode.type;
  if (typeof type === "function") {
    return unwrap(type(vnode.props ?? {}));
  }
  if (typeof type === "object" && "$" in type)
    return type;
  const props = { ...vnode.props };
  if ("css" in props && "__EMOTION_TYPE_PLEASE_DO_NOT_USE__" in props) {
    props.style = props.css.styles;
    type = props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.css;
  }
  const children = vnode.props?.children;
  if (children !== void 0 && children !== null) {
    props.children = flatten(vnode.props.children).map(
      (child) => unwrap(child)
    );
  }
  return {
    type,
    props
  };
};
const flatten = (rawChildren) => {
  if (rawChildren === void 0 || rawChildren === null)
    return [];
  if (typeof rawChildren === "object" && "type" in rawChildren && rawChildren.type === Fragment) {
    return flatten(rawChildren.props.children);
  }
  if (!Array.isArray(rawChildren) || typeof rawChildren === "object" && "$" in rawChildren) {
    return [rawChildren];
  }
  const flattenedChildren = rawChildren.flat(Infinity);
  const children = [];
  for (let i = 0, l = flattenedChildren.length; i < l; ++i) {
    children.push(...flatten(flattenedChildren[i]));
  }
  return children;
};

export { processProps as p, renderReactScope as r, unwrap as u };
