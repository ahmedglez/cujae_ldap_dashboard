'use client';
import { useRef, useCallback, useMemo, createElement, Fragment, useEffect, memo } from 'react';
import { b as block$1, q as queueMicrotask$, d as mount$, p as patch, e as arrayPatch$, a as mapArray, g as arrayMount$ } from './chunks/block.mjs';
import { j as MapHas$, h as MapSet$, k as MapGet$ } from './chunks/constants.mjs';
import { u as unwrap, p as processProps, r as renderReactScope } from './chunks/utils.mjs';
export { r as renderReactScope, u as unwrap } from './chunks/utils.mjs';
import { R as REGISTRY, E as Effect, S as SVG_RENDER_SCOPE, a as RENDER_SCOPE } from './chunks/constants2.mjs';
export { R as REGISTRY } from './chunks/constants2.mjs';
import 'react-dom/client';

const block = (fn, { block: compiledBlock, shouldUpdate, svg, as } = {}) => {
  const block2 = fn ? block$1(fn, unwrap, shouldUpdate, svg) : compiledBlock;
  const defaultType = svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;
  const MillionBlock = (props) => {
    const ref = useRef(null);
    const patch$1 = useRef(null);
    props = processProps(props);
    patch$1.current?.(props);
    const effect = useCallback(() => {
      const currentBlock = block2(props, props.key);
      if (ref.current && patch$1.current === null) {
        queueMicrotask$(() => {
          mount$.call(currentBlock, ref.current, null);
        });
        patch$1.current = (props2) => {
          queueMicrotask$(() => {
            patch(currentBlock, block2(props2, props2.key, shouldUpdate));
          });
        };
      }
    }, []);
    const marker = useMemo(() => {
      return createElement(as ?? defaultType, { ref });
    }, []);
    const vnode = createElement(
      Fragment,
      null,
      marker,
      createElement(Effect, { effect })
    );
    return vnode;
  };
  if (!MapHas$.call(REGISTRY, MillionBlock)) {
    MapSet$.call(REGISTRY, MillionBlock, block2);
  }
  return MillionBlock;
};

const MillionArray = ({
  each,
  children,
  memo: memo2,
  svg,
  as,
  ...rest
}) => {
  const ref = useRef(null);
  const fragmentRef = useRef(null);
  const cache = useRef({
    each: null,
    children: null,
    mounted: null
  });
  if (fragmentRef.current && (each !== cache.current.each || !memo2)) {
    queueMicrotask$(() => {
      const newChildren = createChildren(each, children, cache, memo2);
      arrayPatch$.call(fragmentRef.current, mapArray(newChildren));
    });
  }
  const defaultType = svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;
  const MillionFor = createElement(as ?? defaultType, { ...rest, ref });
  useEffect(() => {
    if (!ref.current || fragmentRef.current)
      return;
    queueMicrotask$(() => {
      if (cache.current.mounted)
        ref.current.textContent = "";
      const newChildren = createChildren(each, children, cache, memo2);
      fragmentRef.current = mapArray(newChildren);
      if (!MapHas$.call(REGISTRY, MillionFor)) {
        MapSet$.call(REGISTRY, MillionFor, fragmentRef.current);
      }
      arrayMount$.call(fragmentRef.current, ref.current);
      cache.current.mounted = true;
    });
  }, [ref.current]);
  return MillionFor;
};
const typedMemo = memo;
const For = typedMemo(MillionArray);
const createChildren = (each, getComponent, cache, memo2) => {
  const children = Array(each.length);
  const currentCache = cache.current;
  for (let i = 0, l = each.length; i < l; ++i) {
    if (memo2 && currentCache.each && currentCache.each[i] === each[i]) {
      children[i] = currentCache.children?.[i];
      continue;
    }
    const vnode = getComponent(each[i], i);
    if (MapHas$.call(REGISTRY, vnode.type)) {
      if (!currentCache.block) {
        currentCache.block = MapGet$.call(REGISTRY, vnode.type);
      }
      children[i] = currentCache.block(vnode.props);
      continue;
    }
    if (typeof vnode.type === "function" && "callable" in vnode.type) {
      const puppetComponent = vnode.type(vnode.props);
      if (MapHas$.call(REGISTRY, puppetComponent.type)) {
        const puppetBlock = MapGet$.call(REGISTRY, puppetComponent.type);
        if (typeof puppetBlock === "function") {
          children[i] = puppetBlock(puppetComponent.props);
          continue;
        }
      }
    }
    const block = block$1((props) => props?.scope);
    const currentBlock = (props) => {
      return block(
        {
          scope: renderReactScope(createElement(vnode.type, props))
        },
        vnode.key ? String(vnode.key) : void 0
      );
    };
    MapSet$.call(REGISTRY, vnode.type, currentBlock);
    currentCache.block = currentBlock;
    children[i] = currentBlock(vnode.props);
  }
  currentCache.each = each;
  currentCache.children = children;
  return children;
};

const macro = (expression) => expression;

export { For, block, macro };
